<!DOCTYPE html>
<html lang="pt-BR" xml:lang="pt-BR">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>6.2 Detecção de Bordas | Material introdutório de Processamento Digital de Imagens e Visão Computacional</title>
  <meta name="description" content="6.2 Detecção de Bordas | Material introdutório de Processamento Digital de Imagens e Visão Computacional" />
  <meta name="generator" content="bookdown 0.22 and GitBook 2.6.7" />

  <meta property="og:title" content="6.2 Detecção de Bordas | Material introdutório de Processamento Digital de Imagens e Visão Computacional" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="6.2 Detecção de Bordas | Material introdutório de Processamento Digital de Imagens e Visão Computacional" />
  
  
  

<meta name="author" content="" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="detecção-por-descontinuidade.html"/>
<link rel="next" href="transformada-de-hough.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<script src="libs/accessible-code-block-0.0.1/empty-anchor.js"></script>
<link href="libs/anchor-sections-1.0.1/anchor-sections.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.0.1/anchor-sections.js"></script>




<link rel="stylesheet" href="css/style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="logo"><a href="./"><img src="imagens/logo.jpeg"></a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Início</a></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Introdução</a><ul>
<li class="chapter" data-level="1.1" data-path="relação-de-processamento-digital-de-imagem-visão-computacional-e-computação-gráfica.html"><a href="relação-de-processamento-digital-de-imagem-visão-computacional-e-computação-gráfica.html"><i class="fa fa-check"></i><b>1.1</b> Relação de Processamento Digital de Imagem, Visão Computacional e Computação Gráfica</a></li>
<li class="chapter" data-level="1.2" data-path="aplicações-processamento-digital-de-imagens.html"><a href="aplicações-processamento-digital-de-imagens.html"><i class="fa fa-check"></i><b>1.2</b> Aplicações Processamento Digital de Imagens</a></li>
<li class="chapter" data-level="1.3" data-path="etapas-do-processamento-e-análise-de-imagens.html"><a href="etapas-do-processamento-e-análise-de-imagens.html"><i class="fa fa-check"></i><b>1.3</b> Etapas do Processamento e Análise de Imagens</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="formação-da-imagem.html"><a href="formação-da-imagem.html"><i class="fa fa-check"></i><b>2</b> Formação da imagem</a><ul>
<li class="chapter" data-level="2.1" data-path="câmera-pinhole-e-geometria.html"><a href="câmera-pinhole-e-geometria.html"><i class="fa fa-check"></i><b>2.1</b> Câmera pinhole e geometria</a></li>
<li class="chapter" data-level="2.2" data-path="lentes.html"><a href="lentes.html"><i class="fa fa-check"></i><b>2.2</b> Lentes</a></li>
<li class="chapter" data-level="2.3" data-path="sensor.html"><a href="sensor.html"><i class="fa fa-check"></i><b>2.3</b> Sensor</a></li>
<li class="chapter" data-level="2.4" data-path="amostragem-e-quantização.html"><a href="amostragem-e-quantização.html"><i class="fa fa-check"></i><b>2.4</b> Amostragem e Quantização</a><ul>
<li class="chapter" data-level="2.4.1" data-path="amostragem-e-quantização.html"><a href="amostragem-e-quantização.html#amostragem"><i class="fa fa-check"></i><b>2.4.1</b> Amostragem</a></li>
<li class="chapter" data-level="2.4.2" data-path="amostragem-e-quantização.html"><a href="amostragem-e-quantização.html#quantização"><i class="fa fa-check"></i><b>2.4.2</b> Quantização</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="definição-de-imagem-digital.html"><a href="definição-de-imagem-digital.html"><i class="fa fa-check"></i><b>2.5</b> Definição de imagem digital</a></li>
<li class="chapter" data-level="2.6" data-path="resolução-espacial-e-de-intensidade.html"><a href="resolução-espacial-e-de-intensidade.html"><i class="fa fa-check"></i><b>2.6</b> Resolução espacial e de intensidade</a></li>
<li class="chapter" data-level="2.7" data-path="pixels.html"><a href="pixels.html"><i class="fa fa-check"></i><b>2.7</b> Pixels</a><ul>
<li class="chapter" data-level="2.7.1" data-path="pixels.html"><a href="pixels.html#vizinhança"><i class="fa fa-check"></i><b>2.7.1</b> Vizinhança</a></li>
<li class="chapter" data-level="2.7.2" data-path="pixels.html"><a href="pixels.html#conectividade"><i class="fa fa-check"></i><b>2.7.2</b> Conectividade</a></li>
<li class="chapter" data-level="2.7.3" data-path="pixels.html"><a href="pixels.html#adjacência"><i class="fa fa-check"></i><b>2.7.3</b> Adjacência</a></li>
<li class="chapter" data-level="2.7.4" data-path="pixels.html"><a href="pixels.html#componente-conexa"><i class="fa fa-check"></i><b>2.7.4</b> Componente Conexa</a></li>
<li class="chapter" data-level="2.7.5" data-path="pixels.html"><a href="pixels.html#medidas-de-distância"><i class="fa fa-check"></i><b>2.7.5</b> Medidas de Distância</a></li>
<li class="chapter" data-level="2.7.6" data-path="pixels.html"><a href="pixels.html#operações-lógico-aritméticas"><i class="fa fa-check"></i><b>2.7.6</b> Operações Lógico-aritméticas</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="transformacões-geométricas.html"><a href="transformacões-geométricas.html"><i class="fa fa-check"></i><b>3</b> Transformacões geométricas</a><ul>
<li class="chapter" data-level="3.1" data-path="definição.html"><a href="definição.html"><i class="fa fa-check"></i><b>3.1</b> Definição</a></li>
<li class="chapter" data-level="3.2" data-path="sistema-de-coordenadas-objetos-2d-e-3d.html"><a href="sistema-de-coordenadas-objetos-2d-e-3d.html"><i class="fa fa-check"></i><b>3.2</b> Sistema de coordenadas objetos (2D e 3D)</a></li>
<li class="chapter" data-level="3.3" data-path="representação-vetorial-e-matricial-de-imagens-digitalizadas.html"><a href="representação-vetorial-e-matricial-de-imagens-digitalizadas.html"><i class="fa fa-check"></i><b>3.3</b> Representação Vetorial e Matricial de Imagens digitalizadas</a></li>
<li class="chapter" data-level="3.4" data-path="matrizes-em-computação-gráfica.html"><a href="matrizes-em-computação-gráfica.html"><i class="fa fa-check"></i><b>3.4</b> Matrizes em Computação gráfica</a></li>
<li class="chapter" data-level="3.5" data-path="transformações-em-pontos-e-objetos.html"><a href="transformações-em-pontos-e-objetos.html"><i class="fa fa-check"></i><b>3.5</b> Transformações em Pontos e Objetos</a></li>
<li class="chapter" data-level="3.6" data-path="transformação-de-translação.html"><a href="transformação-de-translação.html"><i class="fa fa-check"></i><b>3.6</b> Transformação de Translação</a></li>
<li class="chapter" data-level="3.7" data-path="transformação-de-escala.html"><a href="transformação-de-escala.html"><i class="fa fa-check"></i><b>3.7</b> Transformação de Escala</a></li>
<li class="chapter" data-level="3.8" data-path="transformação-de-rotação.html"><a href="transformação-de-rotação.html"><i class="fa fa-check"></i><b>3.8</b> Transformação de Rotação</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="transformações-radiométricas.html"><a href="transformações-radiométricas.html"><i class="fa fa-check"></i><b>4</b> Transformações radiométricas</a><ul>
<li class="chapter" data-level="4.1" data-path="transformação-linear.html"><a href="transformação-linear.html"><i class="fa fa-check"></i><b>4.1</b> Transformação Linear</a></li>
<li class="chapter" data-level="4.2" data-path="transformação-logarítmica.html"><a href="transformação-logarítmica.html"><i class="fa fa-check"></i><b>4.2</b> Transformação Logarítmica</a></li>
<li class="chapter" data-level="4.3" data-path="transformação-de-potência.html"><a href="transformação-de-potência.html"><i class="fa fa-check"></i><b>4.3</b> Transformação de Potência</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="filtros.html"><a href="filtros.html"><i class="fa fa-check"></i><b>5</b> Filtros</a><ul>
<li class="chapter" data-level="5.1" data-path="convolução.html"><a href="convolução.html"><i class="fa fa-check"></i><b>5.1</b> Convolução</a><ul>
<li class="chapter" data-level="5.1.1" data-path="convolução.html"><a href="convolução.html#definção-matemática-de-convolução"><i class="fa fa-check"></i><b>5.1.1</b> Definção matemática de convolução</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="média.html"><a href="média.html"><i class="fa fa-check"></i><b>5.2</b> Média</a></li>
<li class="chapter" data-level="5.3" data-path="mediana.html"><a href="mediana.html"><i class="fa fa-check"></i><b>5.3</b> Mediana</a></li>
<li class="chapter" data-level="5.4" data-path="gaussiano.html"><a href="gaussiano.html"><i class="fa fa-check"></i><b>5.4</b> Gaussiano</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="segmentação.html"><a href="segmentação.html"><i class="fa fa-check"></i><b>6</b> Segmentação</a><ul>
<li class="chapter" data-level="6.1" data-path="detecção-por-descontinuidade.html"><a href="detecção-por-descontinuidade.html"><i class="fa fa-check"></i><b>6.1</b> Detecção por descontinuidade</a><ul>
<li class="chapter" data-level="6.1.1" data-path="detecção-por-descontinuidade.html"><a href="detecção-por-descontinuidade.html#detecção-de-pontos-isolados"><i class="fa fa-check"></i><b>6.1.1</b> Detecção de pontos isolados</a></li>
<li class="chapter" data-level="6.1.2" data-path="detecção-por-descontinuidade.html"><a href="detecção-por-descontinuidade.html#detecção-de-linhas"><i class="fa fa-check"></i><b>6.1.2</b> Detecção de linhas</a></li>
</ul></li>
<li class="chapter" data-level="6.2" data-path="detecção-de-bordas.html"><a href="detecção-de-bordas.html"><i class="fa fa-check"></i><b>6.2</b> Detecção de Bordas</a><ul>
<li class="chapter" data-level="6.2.1" data-path="detecção-de-bordas.html"><a href="detecção-de-bordas.html#modelos-de-bordas"><i class="fa fa-check"></i><b>6.2.1</b> Modelos de Bordas</a></li>
<li class="chapter" data-level="6.2.2" data-path="detecção-de-bordas.html"><a href="detecção-de-bordas.html#método-do-gradiente-roberts-prewitt-sobel"><i class="fa fa-check"></i><b>6.2.2</b> Método do gradiente ( Roberts, Prewitt, Sobel)</a></li>
<li class="chapter" data-level="6.2.3" data-path="detecção-de-bordas.html"><a href="detecção-de-bordas.html#método-de-marr-hildreth"><i class="fa fa-check"></i><b>6.2.3</b> Método de Marr-Hildreth</a></li>
<li class="chapter" data-level="6.2.4" data-path="detecção-de-bordas.html"><a href="detecção-de-bordas.html#método-de-canny"><i class="fa fa-check"></i><b>6.2.4</b> Método de Canny</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="transformada-de-hough.html"><a href="transformada-de-hough.html"><i class="fa fa-check"></i><b>6.3</b> Transformada de Hough</a><ul>
<li class="chapter" data-level="6.3.1" data-path="transformada-de-hough.html"><a href="transformada-de-hough.html#transformada-de-hough-para-detecção-de-linhas"><i class="fa fa-check"></i><b>6.3.1</b> Transformada de Hough para detecção de linhas</a></li>
<li class="chapter" data-level="6.3.2" data-path="transformada-de-hough.html"><a href="transformada-de-hough.html#transformada-de-hough-para-detecção-de-círculos"><i class="fa fa-check"></i><b>6.3.2</b> Transformada de Hough para detecção de círculos</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="detecção-de-quinas.html"><a href="detecção-de-quinas.html"><i class="fa fa-check"></i><b>6.4</b> Detecção de Quinas</a><ul>
<li class="chapter" data-level="6.4.1" data-path="detecção-de-quinas.html"><a href="detecção-de-quinas.html#detector-de-quinas-de-moravec"><i class="fa fa-check"></i><b>6.4.1</b> Detector de Quinas de Moravec</a></li>
<li class="chapter" data-level="6.4.2" data-path="detecção-de-quinas.html"><a href="detecção-de-quinas.html#detector-de-quinas-de-harris"><i class="fa fa-check"></i><b>6.4.2</b> Detector de Quinas de Harris</a></li>
</ul></li>
<li class="chapter" data-level="6.5" data-path="detecção-de-blobs.html"><a href="detecção-de-blobs.html"><i class="fa fa-check"></i><b>6.5</b> Detecção de Blobs</a><ul>
<li class="chapter" data-level="6.5.1" data-path="detecção-de-blobs.html"><a href="detecção-de-blobs.html#log"><i class="fa fa-check"></i><b>6.5.1</b> LoG</a></li>
<li class="chapter" data-level="6.5.2" data-path="detecção-de-blobs.html"><a href="detecção-de-blobs.html#dog"><i class="fa fa-check"></i><b>6.5.2</b> DoG</a></li>
<li class="chapter" data-level="6.5.3" data-path="detecção-de-blobs.html"><a href="detecção-de-blobs.html#doh"><i class="fa fa-check"></i><b>6.5.3</b> DoH</a></li>
</ul></li>
<li class="chapter" data-level="6.6" data-path="limiarização.html"><a href="limiarização.html"><i class="fa fa-check"></i><b>6.6</b> Limiarização</a><ul>
<li class="chapter" data-level="6.6.1" data-path="limiarização.html"><a href="limiarização.html#limiarização-global-simples"><i class="fa fa-check"></i><b>6.6.1</b> Limiarização global simples</a></li>
<li class="chapter" data-level="6.6.2" data-path="limiarização.html"><a href="limiarização.html#limiarização-pelo-método-de-otsu"><i class="fa fa-check"></i><b>6.6.2</b> Limiarização pelo Método de Otsu</a></li>
<li class="chapter" data-level="6.6.3" data-path="limiarização.html"><a href="limiarização.html#uso-de-suavização-para-limiarização"><i class="fa fa-check"></i><b>6.6.3</b> Uso de suavização para limiarização</a></li>
<li class="chapter" data-level="6.6.4" data-path="limiarização.html"><a href="limiarização.html#uso-de-bordas-para-limiarização"><i class="fa fa-check"></i><b>6.6.4</b> Uso de bordas para limiarização</a></li>
<li class="chapter" data-level="6.6.5" data-path="limiarização.html"><a href="limiarização.html#limiares-múltiplos"><i class="fa fa-check"></i><b>6.6.5</b> Limiares Múltiplos</a></li>
<li class="chapter" data-level="6.6.6" data-path="limiarização.html"><a href="limiarização.html#limiarização-variável"><i class="fa fa-check"></i><b>6.6.6</b> Limiarização variável</a></li>
<li class="chapter" data-level="6.6.7" data-path="limiarização.html"><a href="limiarização.html#particionamento-da-imagem"><i class="fa fa-check"></i><b>6.6.7</b> Particionamento da imagem</a></li>
<li class="chapter" data-level="6.6.8" data-path="limiarização.html"><a href="limiarização.html#limiarização-variável-baseada-nas-propriedades-locais-da-imagem"><i class="fa fa-check"></i><b>6.6.8</b> Limiarização variável baseada nas propriedades locais da imagem</a></li>
<li class="chapter" data-level="6.6.9" data-path="limiarização.html"><a href="limiarização.html#usando-média-de-movimento"><i class="fa fa-check"></i><b>6.6.9</b> Usando média de movimento</a></li>
<li class="chapter" data-level="6.6.10" data-path="limiarização.html"><a href="limiarização.html#limiarização-baseada-em-diversas-variáveis"><i class="fa fa-check"></i><b>6.6.10</b> Limiarização baseada em diversas variáveis</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="refêrencias.html"><a href="refêrencias.html"><i class="fa fa-check"></i>Refêrencias</a></li>
<li class="divider"></li>
<li><center>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
<img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />
</a></li></center>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Material introdutório de Processamento Digital de Imagens e Visão Computacional</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="detecção-de-bordas" class="section level2">
<h2><span class="header-section-number">6.2</span> Detecção de Bordas</h2>
<div id="modelos-de-bordas" class="section level3">
<h3><span class="header-section-number">6.2.1</span> Modelos de Bordas</h3>
<p>Na Figura <a href="detecção-de-bordas.html#fig:modelosBordas">6.5</a> estão os principais modelos de borda, que são classificados de acordo com os perfis de intensidade. A primeira borda, borda em degrau, apresenta uma transição entre dois níveis de intensidade e são consideradas ideais com uma distância de <span class="math inline">\(1\)</span> <em>pixel</em>. Na prática, as bordas nas imagens digitais não apresentam uma transição tão bem definida, assim modelos mais apropriados consideram um perfil de rampa como na Figura <a href="detecção-de-bordas.html#fig:modelosBordas">6.5</a> (b) <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 462]</span>. Quanto mais indefinida é a transição da borda, menor é a inclinação da rampa. Em vez de uma borda com <span class="math inline">\(1\)</span> <em>pixel</em> de espessura, todos os pontos na rampa fazem parte da borda.
Figura - Modelos de bordas com seus respectivos perfis de intensidade.</p>

<div class="figure" style="text-align: center"><span id="fig:modelosBordas"></span>
<img src="imagens/06-segmentacao/modelosBordas.png" alt="(a) Borda degrau. (b) Borda rampa. (c) Borda telhado. [2, p. 462]" width="55%" />
<p class="caption">
Figura 6.5: (a) Borda degrau. (b) Borda rampa. (c) Borda telhado. <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 462]</span>
</p>
</div>
<p>No terceiro modelo de borda, Figura <a href="detecção-de-bordas.html#fig:modelosBordas">6.5</a> (c), em forma de telhado ou <em>roof edge</em>, a base (largura) de uma borda é definida pela espessura e a nitidez da linha. Quando a base é igual <span class="math inline">\(1\)</span> <em>pixel</em> de espessura, uma borda em forma de telhado é definida como uma linha <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 462]</span>.</p>
<p>As imagens da Figura <a href="detecção-de-bordas.html#fig:derivadasImagensRuidosas">6.6</a> não apresentam ruídos, entretanto os modelos de detecção devem considerar que as bordas estejam desfocadas e com ruídos. Na primeira coluna da Figura estão três bordas de perfil rampa com diferentes níveis de ruídos, e abaixo de cada imagem está o perfil horizontal de intensidade que passa pelo centro da imagem. A primeira imagem no canto esquerdo não apresenta ruído, e as outras duas imagens da primeira coluna foram alteradas com ruído gaussiano aditivo com média zero e desvio padrão de <span class="math inline">\(0.1\)</span> e <span class="math inline">\(1.0\)</span> níveis de intensidade, respectivamente.</p>

<div class="figure" style="text-align: center"><span id="fig:derivadasImagensRuidosas"></span>
<img src="imagens/06-segmentacao/derivadasImagensRuidosas.png" alt="Primeira coluna: imagens e perfis de intensidade de uma borda em declive corrompida pelo ruído gaussiano aleatório de desvio padrão \(0.0\), \(0.1\) e \(1.0\) níveis de intensidade, respectivamente. Segunda coluna: imagens da primeira derivada. Terceira coluna: imagens da segunda derivada. [2, p. 465]" width="55%" />
<p class="caption">
Figura 6.6: Primeira coluna: imagens e perfis de intensidade de uma borda em declive corrompida pelo ruído gaussiano aleatório de desvio padrão <span class="math inline">\(0.0\)</span>, <span class="math inline">\(0.1\)</span> e <span class="math inline">\(1.0\)</span> níveis de intensidade, respectivamente. Segunda coluna: imagens da primeira derivada. Terceira coluna: imagens da segunda derivada. <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 465]</span>
</p>
</div>
<p>Na segunda e terceira coluna estão identificados, respectivamente, a primeira e a segunda derivada dos perfis de intensidade da primeira coluna. A primeira derivada é utilizada para detectar bordas, pois identifica pontos de transição abrupta de intensidade na imagem. Para o resultado da primeira derivada na primeira linha, os valores na rampa são positivos e, nas regiões de intensidade constante é igual a zero. As duas faixas pretas na imagem da parte superior da coluna central são os resultados iguais a zero da primeira derivada, e os valores constantes estão identificados como cinza claro.</p>
<p>Como as bordas são uma transição de uma região escura para uma região branca, a segunda derivada na terceira coluna é positiva no início da rampa e negativa no final. A linha que passa por estes dois resultados da derivada se intercepta com o eixo de intensidade zero, gerando o ponto de cruzamento por zero que é utilizado para localizar o centro de bordas espessas <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 464]</span>. Nas regiões de intensidade constante as derivadas de segunda ordem também são zero, e se apresentam na cor cinza claro nas imagens da terceira coluna. As linhas finas verticais brancas e pretas são os resultados positivos e negativos da segunda derivada.</p>
<p>Mesmo não sendo perceptível os ruídos nas imagens da segunda e terceira linha, eles apresentaram um impacto significativo nas derivadas, principalmente na derivada de segunda ordem que é mais sensível aos ruídos. Quanto maior o ruído mais difícil de se associar com os perfis das derivadas, dificultando a detecção de bordas. Este comportamento pode ser tratado com a suavização da imagem em uma etapa anterior a segmentação <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 464]</span>.</p>
</div>
<div id="método-do-gradiente-roberts-prewitt-sobel" class="section level3">
<h3><span class="header-section-number">6.2.2</span> Método do gradiente ( Roberts, Prewitt, Sobel)</h3>
<p>Na detecção de bordas, as derivadas de primeira ordem são calculadas utilizando a magnitude do gradiente, que é um vetor cuja a direção indica os pontos de maior variação de intensidade <span class="citation">[<a href="#ref-pedrini2008" role="doc-biblioref">3</a>, p. 155]</span>. Na figura indica que a direção do gradiente sempre será perpendicular à direção tangente da borda. Para uma função <span class="math inline">\(f(x, y)\)</span>, o gradiente de <span class="math inline">\(f\)</span> nas coordenadas <span class="math inline">\((x, y)\)</span> na forma matricial é expresso como:</p>
<p><span class="math display">\[\nabla f 
= \begin{bmatrix}
G_x
\\ G_y
\end{bmatrix}
= \begin{bmatrix}
\frac{\partial f}{\partial x}
\\ \frac{\partial f}{\partial y}
\end{bmatrix}\]</span></p>

<div class="figure" style="text-align: center"><span id="fig:vetorGradiente"></span>
<img src="imagens/06-segmentacao/vetorGradiente.png" alt="Vetor gradiente \(\nabla f\) em uma borda. [3, p. 155]" width="55%" />
<p class="caption">
Figura 6.7: Vetor gradiente <span class="math inline">\(\nabla f\)</span> em uma borda. <span class="citation">[<a href="#ref-pedrini2008" role="doc-biblioref">3</a>, p. 155]</span>
</p>
</div>
<p>O módulo ou magnitude (tamanho) do vetor <span class="math inline">\(\nabla f\)</span> é dado como <span class="math inline">\(M(x,y)\)</span>:
<span class="math display">\[M(x,y) = \sqrt{G^2_x + G^2_y}\]</span></p>
<p>O módulo do gradiente é a maior taxa de variação de <span class="math inline">\(f(x,y)\)</span> na direção do vetor gradiente. Devido ao custo computacional, a magnitude do gradiente é aproximada pelo uso dos valores absolutos <span class="citation">[<a href="#ref-pedrini2008" role="doc-biblioref">3</a>, p. 155]</span>:
<span class="math display">\[M(x,y) \simeq |G_x| + |G_y|\]</span>
A direção do vetor gradiente é dada pelo ângulo:
<span class="math display">\[
\alpha(x,y) = 
tg^{-1}
\begin{bmatrix}
\frac{G_y}{G_x}
\end{bmatrix}
\]</span></p>
<p>medido em relação ao eixo <span class="math inline">\(x\)</span>. Da mesma forma que a magnitude <span class="math inline">\(M(x, y)\)</span>, ou imagem gradiente, o ângulo <span class="math inline">\(\alpha(x, y)\)</span> também é uma imagem do mesmo tamanho que a original formado pela divisão da imagem <span class="math inline">\(G_y\)</span> por <span class="math inline">\(G_x\)</span> <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 466]</span>.</p>
<p>Para calcular as derivadas parciais <span class="math inline">\(\partial f/ \partial x\)</span> e <span class="math inline">\(\partial f/ \partial y\)</span> no caso de quantidades digitais é necessário utilizar aproximações discretas e, em seguida, determinar as máscaras de filtragem correspondentes. Uma forma de aproximação é considerar a diferença entre os elementos da vizinhança para calcular a magnitude do gradiente <span class="citation">[<a href="#ref-pedrini2008" role="doc-biblioref">3</a>, p. 157]</span>. Ao se utilizar as diferenças cruzadas como na seguinte equação:</p>
<p><span class="math display">\[M(x,y) \simeq |f(x,y) - f(x+1, y+1)| + |f(x,y+1) - f(x+1, y)|\]</span>
é o mesmo que aplicar os filtros de tamanho 2x2 da Figura <a href="detecção-de-bordas.html#fig:operadorRoberts">6.8</a> e somar os resultados absolutos.</p>

<div class="figure" style="text-align: center"><span id="fig:operadorRoberts"></span>
<img src="imagens/06-segmentacao/operadorRoberts.png" alt="Operador de Roberts. [3, p. 157]" width="55%" />
<p class="caption">
Figura 6.8: Operador de Roberts. <span class="citation">[<a href="#ref-pedrini2008" role="doc-biblioref">3</a>, p. 157]</span>
</p>
</div>
<p>Estes operadores, conhecidos como operadores de Roberts, foram uma das primeiras tentativas de usar máscaras 2-D, entretanto não são tão úteis quanto máscaras simétricas ao redor do ponto central, em que as menores são de tamanho 3×3 <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 467]</span>. As aproximações mais simples para as derivadas parciais usando máscaras de tamanho 3×3 são dadas por:</p>
<p><span class="math display">\[ 
\begin{split}
M(x,y) &amp;\simeq
|[f(x+1,y-1) + f(x+1,y) + f(x+1,y+1)]-\\
 &amp;\ \ \ \ \ [f(x-1,y-1) + f(x-1,y) + f(x-1,y+1)]+\\
 &amp;\ \ \ \ \ [f(x-1,y+1) + f(x,y+1) + f(x+1,y+1)]-\\
 &amp;\ \ \ \ \ [f(x-1,y-1) + f(x,y-1) + f(x+1,y-1)]|
\end{split}
\]</span></p>

<div class="figure" style="text-align: center"><span id="fig:operadorPrewitt"></span>
<img src="imagens/06-segmentacao/operadorPrewitt.png" alt="Operador de Prewitt. [3, p. 158]" width="55%" />
<p class="caption">
Figura 6.9: Operador de Prewitt. <span class="citation">[<a href="#ref-pedrini2008" role="doc-biblioref">3</a>, p. 158]</span>
</p>
</div>
<p>A equação pode ser implementada aplicando as máscaras da Figura <a href="detecção-de-bordas.html#fig:operadorSobel">6.10</a>, que recebem o nome de operadores de Prewitt. Uma variação deste último método utiliza o valor <span class="math inline">\(2\)</span> como peso no centro do coeficiente <span class="citation">[<a href="#ref-pedrini2008" role="doc-biblioref">3</a>, p. 158]</span>:</p>
<p><span class="math display">\[ 
\begin{split}
M(x,y) &amp;\simeq
|[f(x+1,y-1) + 2f(x+1,y) + 2f(x+1,y+1)]-\\
 &amp;\ \ \ \ \ [f(x-1,y-1) + 2f(x-1,y) + f(x-1,y+1)]+\\
 &amp;\ \ \ \ \ [f(x-1,y+1) + 2f(x,y+1) + f(x+1,y+1)]-\\
 &amp;\ \ \ \ \ [f(x-1,y-1) + 2f(x,y-1) + f(x+1,y-1)]|
\end{split}
\]</span></p>

<div class="figure" style="text-align: center"><span id="fig:operadorSobel"></span>
<img src="imagens/06-segmentacao/operadorSobel.png" alt="Operador de Sobel. [3, p. 158]" width="55%" />
<p class="caption">
Figura 6.10: Operador de Sobel. <span class="citation">[<a href="#ref-pedrini2008" role="doc-biblioref">3</a>, p. 158]</span>
</p>
</div>
<p>O resultado das equações pode ser obtido com a soma dos valores absolutos dos resultados das máscaras na Figura <a href="detecção-de-bordas.html#fig:operadorSobel">6.10</a>, chamadas de operadores de Sobel. Mesmo que as máscaras de Prewitt sejam mais simples de implementar do que as máscaras de Sobel, as de Sobel são mais utilizadas por melhor suavização, diminuindo os ruídos <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 468]</span>.</p>
<p>Ao calcular a magnitude como uma aproximação da soma dos valores absolutos dos componentes de gradiente <span class="math inline">\(G_x\)</span> e <span class="math inline">\(G_y\)</span> (Equação) pode se perder a propriedade isotrópica dos filtros. No caso das máscaras de Sobel e de Prewitt este problema não ocorre, pois dão resultados isotrópicos apenas para bordas verticais e horizontais, e que são independentes da equação ou equação <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 468]</span>.</p>
</div>
<div id="método-de-marr-hildreth" class="section level3">
<h3><span class="header-section-number">6.2.3</span> Método de Marr-Hildreth</h3>
<p>Nos métodos de detecção de bordas utilizando a derivada de segunda ordem se observa maior sensibilidade aos ruídos, assim se recomenda um pré-processamento de suavização. A técnica de detecção proposta por Marr e Hildreth (1980), por exemplo, combina a filtragem Gaussiana com o operador Laplaciano <span class="citation">[<a href="#ref-pedrini2008" role="doc-biblioref">3</a>, p. 163]</span>. Após a suavização da imagem com o filtro gaussiano, as bordas são identificadas pelos pontos de cruzamento por zero da segunda derivada.</p>
<p>Um aspecto que torna a técnica interessante para imagens de diferentes escalas é que considera as características da borda e dos ruídos, empregando-se operadores de tamanho mais adequado para cada imagem <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 470]</span>. Operadores de maior tamanho são recomendados para detectar bordas borradas, enquanto operadores menores detectam melhor detalhes finos com foco nítido. Como o laplaciano é isotrópico, respondendo de forma igual às variações nas diferentes direções, evita-se a utilização de várias máscaras <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 472]</span>.</p>
<p>O operador proposto por Marr e Hildreth é obtido pela convolução:
<span class="math display">\[g(x,y) = \nabla^2[G(x,y)*f(x,y)]\]</span>
em que <span class="math inline">\(f(x,y)\)</span> é a imagem, <span class="math inline">\(\nabla^2\)</span> é o operador laplaciano, (<span class="math inline">\(\partial^2 f / \partial x^2 + \partial^2 f / \partial y^2\)</span>), e <span class="math inline">\(G\)</span> é a função gaussiana 2-D:
<span class="math display">\[G(x,y) = e^{-\frac{x^2 + y^b}{2\sigma^2}}\]</span>
com desvio padrão <span class="math inline">\(\sigma\)</span>. Em razão da linearidade das operações, a ordem da diferenciação e da convolução podem ser alteradas <span class="citation">[<a href="#ref-pedrini2008" role="doc-biblioref">3</a>, p. 163]</span>, assim após a diferenciação da expressão gaussiana se obtém o Laplaciano da Gaussiana (LoG):
<span class="math display">\[\nabla^2G(x,y) = 
\begin{bmatrix}
\frac{x^2 + y^2 - \sigma^2}{\sigma^4} e^{-\frac{x^2 + y^b}{2\sigma^2}}
\end{bmatrix}\]</span></p>
<p>As máscaras podem ser geradas pela amostragem da equação e ajustando os coeficientes para que a soma seja zero. Um exemplo de máscara 5x5 que atende ao Laplaciano da Gaussiana está na Figura <a href="detecção-de-bordas.html#fig:laplacianoGaussiana">6.11</a> (d). O comportamento dessa máscara se aproxima do efeito da função LoG na Figura <a href="detecção-de-bordas.html#fig:laplacianoGaussiana">6.11</a> (a), em que o termo positivo e central é rodeado por uma região negativa cujo os valores aumentam ao se distanciar da origem, e uma região externa com zeros <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 472]</span>.</p>

<div class="figure" style="text-align: center"><span id="fig:laplacianoGaussiana"></span>
<img src="imagens/06-segmentacao/laplacianoGaussiana.png" alt="(a) Gráfico 3-D do negativo de LoG. (b) Imagem do negativo de LoG. (c) Seção transversal de (a). (d) Aproximação de máscara 5x5 para LoG. [2, p. 471]" width="55%" />
<p class="caption">
Figura 6.11: (a) Gráfico 3-D do negativo de LoG. (b) Imagem do negativo de LoG. (c) Seção transversal de (a). (d) Aproximação de máscara 5x5 para LoG. <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 471]</span>
</p>
</div>
<p>Devido ao formato na Figura <a href="detecção-de-bordas.html#fig:laplacianoGaussiana">6.11</a> a função LoG é conhecida como operador de chapéu mexicano. Na Figura <a href="detecção-de-bordas.html#fig:laplacianoGaussiana">6.11</a> o gráfico 3-D, a imagem e a seção transversal se referem ao negativo da função LoG. Na seção transversal (Figura <a href="detecção-de-bordas.html#fig:laplacianoGaussiana">6.11</a> (c)), o cruzamento por zero do LoG ocorre em <span class="math inline">\(x^2 + y^2 = 2 \sigma^2\)</span> , definindo um círculo centrado na origem e de raio <span class="math inline">\(2\sigma\)</span>.</p>
<p>Na prática, o filtro LoG é gerado pelas seguintes etapas <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 472]</span>:</p>
<ol style="list-style-type: decimal">
<li><p>Define-se um filtro <span class="math inline">\(n\)</span>×<span class="math inline">\(n\)</span> gaussiano a partir de amostragem com a equação. Lembrando da sugestão que para tamanho do filtro gaussiano <span class="math inline">\(n\)</span> seja o menor inteiro ímpar maior ou igual a <span class="math inline">\(6\sigma\)</span>.</p></li>
<li><p>Após suavização da imagem com o filtro gaussiano, o resultado é processado pelo laplaciano, por exemplo, com uma máscara 3×3 na Figura.</p></li>
<li><p>Na imagem resultante da etapa anterior são encontrados os pontos de cruzamento por zero. Estes pontos podem ser identificados em um <em>pixel</em>, <span class="math inline">\(p\)</span>, com base na sua vizinhança de 3x3. No caso de <span class="math inline">\(p\)</span> ser um cruzamento por zero, pelo menos dois de seus vizinhos opostos devem apresentar sinais diferentes. Neste caso são realizados quatro testes: esquerda/direita, acima/abaixo e com as duas diagonais. Quando se utiliza um limiar para identificar o cruzamento por zero, tanto os sinais dos vizinhos opostos devem ser diferentes quanto o valor absoluto da diferença numérica deve ultrapassar o limiar para que o ponto <span class="math inline">\(p\)</span> seja um cruzamento por zero.</p></li>
</ol>
<p>O filtro LoG também pode ser aproximado com a convolução de uma máscara gerada a partir da diferença de duas funções gaussianas (DoG) <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 473]</span>:
<span class="math display">\[DoG(x,y) = \frac{1}{2\pi \sigma^2_1}  e^  {-\frac{x^2+y^2}{2\sigma^2_1}}
-
\frac{1}{2\pi \sigma^2_2}  e^  {-\frac{x^2+y^2}{2\sigma^2_2}}\]</span></p>
<p>com <span class="math inline">\(\sigma_1 &gt; \sigma_2\)</span>. Marr e Hildreth mostraram que para <span class="math inline">\(\sigma_2/\sigma_1 = 1.6\)</span> o operador tem maior aproximação com a função LoG <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 473]</span>. Para que LoG e DoG tenham os mesmos cruzamentos por zero se sugere que se mantenha a seguinte relação para o valor de <span class="math inline">\(\sigma\)</span> em LoG:
<span class="math display">\[\sigma^2 = \frac{\sigma^2_1\sigma^2_2}{\sigma^2_1 - \sigma^2_2}
\ln 
\begin{bmatrix}
\frac{\sigma^2_1}{\sigma^2_2}
\end{bmatrix}\]</span></p>
<p>Para estabelecer uma mesma escala de amplitude no resultado dos dois operadores, ocorre um ajuste para o mesmo valor na origem em ambas as funções <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 474]</span>.</p>
</div>
<div id="método-de-canny" class="section level3">
<h3><span class="header-section-number">6.2.4</span> Método de Canny</h3>
<p>O algoritmo de Canny recebeu esse nome em alusão a John Canny, que o propôs em seu artigo, “A computational Approach to Edge Detection”<span class="citation">[<a href="#ref-canny1986computational" role="doc-biblioref">17</a>]</span>, publicado em 1986. Sua formulação se baseava em três pontos principais:</p>
<ul>
<li>Uma baixa taxa de erro, ou seja, todas as bordas presentes na imagem devem ser encontradas e não deve haver respostas espúrias.</li>
<li>O segundo critério diz que as bordas detectadas devem estar bem localizadas, em outras palavras, elas devem estar o mais próximo possível das bordas verdadeiras.</li>
<li>O terceiro e último critério diz que se deve minimizar o número de máximos locais em torno da borda verdadeira, para que não sejam encontrados múltiplos pixels de borda onde deve haver somente um.</li>
</ul>
<p>Em seu trabalho, Canny buscou encontrar soluções ótimas, matematicamente, que obedecessem os três critérios. Apesar disso, é muito difícil, ou impossível, encontrar uma solução que satisfaça completamente os objetivos descritos<span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 474]</span>. Todavia é possível utilizar uma aproximação por meio de otimização numérica com as bordas em degrau em um exemplo 1-D que contenham ruído branco gaussiano e mostrar que uma boa aproximação para um ótimo detector de bordas é a primeira derivada de uma gaussiana<span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 474]</span>:</p>
<p><span class="math display">\[\frac{\mathrm{d} }{\mathrm{d} x}e^{\frac{-x^2}{2\sigma^2}} = \frac{-x}{\sigma^2}e^{\frac{-x^2}{2\sigma^2}}\]</span></p>
<p>Canny demonstrou que a utilização dessa aproximação pode ser feita com uma taxa 20% inferior à solução numérica, o que a torna praticamente imperceptível para muitas das aplicações<span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 474]</span>.
A ideia anterior foi imaginada em um aspecto 1D, precisamos agora, expandir esse conceito para uma generalização 2D. Uma borda de degrau pode ser caracterizada pela sua posição, orientação e possível magnitude. Aplicar um filtro Gaussiano em uma imagem e depois diferenciá-la forma um simples e efetivo operador direcional<span class="citation">[<a href="#ref-sonka2014" role="doc-biblioref">18</a>, p. 145]</span>. Digamos então que <span class="math inline">\(f(x,y)\)</span> seja uma imagem e <span class="math inline">\(G(x,y)\)</span> a função gaussiana:</p>
<p><span class="math display">\[G(x,y) = e^{-\frac{x^2+y^2}{2\sigma^2}}\]</span></p>
<p>Temos como saída a imagem suavizada:</p>
<p><span class="math display">\[f_s(x,y)=G(x,y)*f(x,y)\]</span></p>
<p>E após isso realizamos o cálculo da magnitude e direção do gradiente:</p>
<p><span class="math display">\[M(x,y) = \sqrt{g_x^2+g_y^2}\]</span>
<span class="math display">\[\alpha(x,y)= \tan^{-1}\left ( \frac{g_y}{g_x} \right )\]</span></p>
<p>onde <span class="math inline">\(g_x=\partial f_s/\partial x\)</span> e <span class="math inline">\(g_y=\partial f_s/\partial y\)</span>. Para o cálculo das derivadas parciais podemos utilizar tanto Prewitt quanto Sobel. Como essa primeira etapa utiliza operadores que calculam as primeiras derivadas, acabamos com bordas grossas, e o terceiro objetivo da proposta de Canny é ter bordas com único ponto, por isso o próximo passo é a de afinar as bordas encontradas. O método que usaremos para isso é chamado supressão dos não máximos. Esse processo tem como base a discretização das direções da normal da borda(vetor gradiente), ou seja, em uma região 3x3 temos 4 direções possíveis, como pode ser visto na figura <a href="detecção-de-bordas.html#fig:edgeorientation">6.12</a>(c), sendo que consideramos 4 pois é contando as duas direções, como exemplo, consideramos um borda de 45º se ela se encontra entre +157,5º e +112,5º ou -67,5º e -22,5º.
Na figura <a href="detecção-de-bordas.html#fig:edgeorientation">6.12</a>(a) temos um exemplo de duas orientações que podem existir em uma borda horizontal, e na figura <a href="detecção-de-bordas.html#fig:edgeorientation">6.12</a>(b) podemos ver a normal de uma borda horizontal e o intervalo de valores onde a direção do vetor gradiente pode existir.</p>

<div class="figure" style="text-align: center"><span id="fig:edgeorientation"></span>
<img src="imagens/06-segmentacao/edge_orientation.png" alt="Discretização das direções. (a)Borda horizontal. (b) Intervalo dos possíveis valores do ângulo, normal da borda, para uma borda horizontal. (c) Intervalo de valores do ângulo da normal para os diferentes tipos de borda. [2, p. 475]" width="70%" />
<p class="caption">
Figura 6.12: Discretização das direções. (a)Borda horizontal. (b) Intervalo dos possíveis valores do ângulo, normal da borda, para uma borda horizontal. (c) Intervalo de valores do ângulo da normal para os diferentes tipos de borda. <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 475]</span>
</p>
</div>
<p>Se consideramos <span class="math inline">\(d1\)</span>, <span class="math inline">\(d2\)</span>, <span class="math inline">\(d3\)</span> e <span class="math inline">\(d4\)</span> como as direções possíveis em uma área 3x3, podemos formular o seguinte esquema de supressão de não máximos de uma região 3x3 centrada em todos os pontos <span class="math inline">\((x,y)\)</span> de <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 475]</span>:
- Encontrar a direção <span class="math inline">\(d_k\)</span> que está mais perto de <span class="math inline">\(\alpha (x,y)\)</span>.
- Se o valor de <span class="math inline">\(M(x,y)\)</span> for inferior a pelo menos um dos seus dois vizinhos ao logo de <span class="math inline">\(d_k\)</span>, deixe <span class="math inline">\(g_N(x,y)=0\)</span>(supressão); caso contrário, deixe <span class="math inline">\(g_N(x,y)=M(x,y)\)</span>.
Onde <span class="math inline">\(g_N(x,y)\)</span> é a imagem suprimida.
A última operação a ser realizada é a limiarização, para se remover os pontos de falsas bordas. Aqui usaremos a limiarização por histerese que utiliza dois limiares, um baixo(<span class="math inline">\(T_L\)</span>) e um alto (<span class="math inline">\(T_H\)</span>), sendo que Canny sugeriu, em seu trabalho, que a razão entre o limiar alto para o baixo deva ser de dois ou três para um.
Podemos imaginar essa limiarização da seguinte forma, criamos duas imagens adicionais:</p>
<p><span class="math display">\[g_{NH}(x,y) = g_N(x,y)\geq T_H\]</span> e <span class="math display">\[g_{NL}(x,y) = g_N(x,y)\geq T_L\]</span></p>
<p>Onde <span class="math inline">\(g_{NH}(x,y)\)</span> e <span class="math inline">\(g_{NL}(x,y)\)</span> são definidas inicialmente como <span class="math inline">\(0\)</span>. Temos então que <span class="math inline">\(g_{NH}(x,y)\)</span>conterá os pixels que são maiores que o nosso limiar e <span class="math inline">\(g_{NL}(x,y)\)</span> terá os pixels que estão acima do nosso limiar baixo, o que significa que ele contém os pixels que se encontram no meio dos dois limiares mais o que está acima do limiar alto, temos então que remover esses pixels, o que significa:
<span class="math display">\[g_{NL}(x,y)=g_{NL}(x,y)-g_{NH}(x,y)\]</span></p>
<p>Podemos chamar os pixels de <span class="math inline">\(g_{NH}(x,y)\)</span> de pixels fortes e os de <span class="math inline">\(g_{NL}(x,y)\)</span> de fracos. Ao final dessa limiarização todos os pixels fortes são classificados como borda válida, mas com falhas, que nos leva a outro processo:</p>
<ul>
<li>Localizar o próximo pixel borda a ser revisado em <span class="math inline">\(g_{NH}(x,y)\)</span>, chamaremos esse pixel de p.</li>
<li>Classificar todos os pixels fracos de <span class="math inline">\(g_{NL}(x,y)\)</span> que tenham conexão, como a conectividade-8, como bordas válidas.</li>
<li>Quando todos os pixels de <span class="math inline">\(g_{NL}(x,y)\)</span> Se forem analisados, pulamos para 4, senão voltamos para 1.</li>
<li>Zerar todos os pixels de <span class="math inline">\(g_{NL}(x,y)\)</span> que não são bordas válidas.</li>
</ul>
<p>Ao final desses processos teremos a imagem de saída do algoritmo de Canny. Como dito por <span class="citation">[<a href="#ref-gonzalez2010" role="doc-biblioref">2</a>, p. 476]</span>, o uso de duas imagens <span class="math inline">\(g_{NH}(x,y)\)</span> e <span class="math inline">\(g_{NL}(x,y)\)</span> é uma boa maneira para se explicar o algoritmo de uma maneira simples, mas na prática isso pode ser feito diretamente na imagem <span class="math inline">\(g_N(x,y)\)</span>.
Por fim, sumarizando os passos do algoritmo, com um exemplo:</p>
<ol style="list-style-type: decimal">
<li>Imagem original</li>
</ol>

<div class="figure" style="text-align: center"><span id="fig:original"></span>
<img src="imagens/06-segmentacao/original.jpg" alt="Imagem original." width="50%" />
<p class="caption">
Figura 6.13: Imagem original.
</p>
</div>
<ol start="2" style="list-style-type: decimal">
<li>Aplicação do filtro gaussiano para suavizar a imagem.</li>
</ol>

<div class="figure" style="text-align: center"><span id="fig:gaussian"></span>
<img src="imagens/06-segmentacao/gaussian.jpg" alt="Imagem filtrada com filtro gaussiano." width="50%" />
<p class="caption">
Figura 6.14: Imagem filtrada com filtro gaussiano.
</p>
</div>
<ol start="3" style="list-style-type: decimal">
<li>Cálculo da magnitude do gradiente e dos ângulos.</li>
</ol>

<div class="figure" style="text-align: center"><span id="fig:derivadas"></span>
<img src="imagens/06-segmentacao/derivadas.jpg" alt="(a) Sobel na direção vertical. (b) Sobel na direção horizontal. (c) Gradiente. (d) Angulos. [8, p. 98]" width="75%" />
<p class="caption">
Figura 6.15: (a) Sobel na direção vertical. (b) Sobel na direção horizontal. (c) Gradiente. (d) Angulos. <span class="citation">[<a href="#ref-burger2009" role="doc-biblioref">8</a>, p. 98]</span>
</p>
</div>
<ol start="4" style="list-style-type: decimal">
<li>Aplicação da supressão não máxima para afinar as bordas.</li>
</ol>

<div class="figure" style="text-align: center"><span id="fig:supressao"></span>
<img src="imagens/06-segmentacao/supressao.jpg" alt="Resultado da supressão não máxima." width="50%" />
<p class="caption">
Figura 6.16: Resultado da supressão não máxima.
</p>
</div>
<ol start="6" style="list-style-type: decimal">
<li>Usar limiarização por histerese e análise de conectividade para detectar e conectar as bordas.</li>
</ol>

<div class="figure" style="text-align: center"><span id="fig:threshold"></span>
<img src="imagens/06-segmentacao/threshold.jpg" alt="Resultado da histerese e conecção de bordas." width="50%" />
<p class="caption">
Figura 6.17: Resultado da histerese e conecção de bordas.
</p>
</div>
<ol start="7" style="list-style-type: decimal">
<li>Resultado final.</li>
</ol>

<div class="figure" style="text-align: center"><span id="fig:canny"></span>
<img src="imagens/06-segmentacao/canny.jpg" alt="Resultado final da detecção de bordas de Canny." width="50%" />
<p class="caption">
Figura 6.18: Resultado final da detecção de bordas de Canny.
</p>
</div>
</div>
</div>
<h3>Refêrencias</h3>
<div id="refs" class="references">
<div id="ref-gonzalez2010">
<p>[2] R. C. Gonzalez e R. C. Woods, <em>Processamento digital de imagens</em>, 3º ed. São Paulo: Pearson Prentice Hall, 2010.</p>
</div>
<div id="ref-pedrini2008">
<p>[3] H. Pedrini e W. Robson Schwartz, <em>Análise de imagens digitais: princípios, algoritmos e aplicações</em>, 3º ed. São Paulo: Thomson Learning Edicoes Ltda, 2007.</p>
</div>
<div id="ref-burger2009">
<p>[8] W. Burger, M. J. Burge, M. J. Burge, e M. J. Burge, <em>Principles of digital image processing</em>, vol. 111. Springer, 2009.</p>
</div>
<div id="ref-canny1986computational">
<p>[17] J. Canny, “A computational approach to edge detection”, <em>IEEE Transactions on pattern analysis and machine intelligence</em>, nº 6, p. 679–698, 1986.</p>
</div>
<div id="ref-sonka2014">
<p>[18] M. Sonka, V. Hlavac, e R. Boyle, <em>Image processing, analysis, and machine vision</em>. Cengage Learning, 2014.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="detecção-por-descontinuidade.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="transformada-de-hough.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": null
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/covap-utfpr/pdi/edit/master/06-segmentacao.Rmd",
"text": "Editar "
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "section"
},
"citation_package": "biblatex"
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
